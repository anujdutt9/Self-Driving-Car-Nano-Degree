# Define Helper Functions

import cv2
import numpy as np


# Function to Convert Image from RGB to Grayscale
def grayscale(img):
    # Convert Image from RGB to Grayscale
    return cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)


# Function to apply Gaussian Blur
def gaussian_blur(img, kernel_size):
    # Apply Gaussian Blurr on Grayscale Image
    return cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)


# Function for Canny Edge Detection
def cannyEdge(img, low_threshold, high_threshold):
    # Return Edges detected in Blurred Grayscale Image
    return cv2.Canny(img, low_threshold, high_threshold)


# Function to take in the Image and Threshold the Yellow Lane Lines in Image
# This function takes in the Edge Detected Image and does an "OR" operation of this image with the input image.
# Using this, we can track the yellow lane lines individually by comparing the two images
def yellow_mask(image):
    # Convert Image from RGB to HSV Domain
    rgb2hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)

    # Define Upper and Lower Threshold for Yellow Color to be detected
    lower_threshold = np.array([20, 100, 200])
    upper_threshold = np.array([30, 255, 255])

    # Threshold the HSV image to get only yellow colors
    mask_yellow = cv2.inRange(rgb2hsv, lower_threshold, upper_threshold)
    # Return the Mask for Yellow Lane Lines
    return mask_yellow


# Function to Define the Polygon Region of Interest to detect Lane Lines
# The rest of the image is set to black.
def region_of_interest(img, vertices):
    # defining a blank mask to start with
    mask = np.zeros_like(img)

    # defining a 3 channel or 1 channel color to fill the mask with depending on the input image
    if len(img.shape) > 2:
        channel_count = img.shape[2]  # i.e. 3 or 4 depending on your image
        ignore_mask_color = (255,) * channel_count
    else:
        ignore_mask_color = 255

    # filling pixels inside the polygon defined by "vertices" with the fill color
    cv2.fillPoly(mask, vertices, ignore_mask_color)

    # returning the image only where mask pixels are nonzero
    masked_image = cv2.bitwise_and(img, mask)
    return masked_image


# Function to plot the Hough Lines for Lanes
# img: Output of Canny Edge
# Returns an image with hough lines drawn.
def hough_lines(img, rho, theta, threshold, min_line_len, max_line_gap):
    lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len,maxLineGap=max_line_gap)
    line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
    draw_lines(line_img, lines)
    return line_img



# --------------------- Draw Lane Lines ----------------------------

# Draw Lane Lines in Image
def draw_lines(img, lines, color=[253, 0, 0], thickness=5):
    """
    NOTE: this is the function you might want to use as a starting point once you want to
    average/extrapolate the line segments you detect to map out the full
    extent of the lane (going from the result shown in raw-lines-example.mp4
    to that shown in P1_example.mp4).

    Think about things like separating line segments by their
    slope ((y2-y1)/(x2-x1)) to decide which segments are part of the left
    line vs. the right line.  Then, you can average the position of each of
    the lines and extrapolate to the top and bottom of the lane.

    This function draws `lines` with `color` and `thickness`.
    Lines are drawn on the image inplace (mutates the image).
    If you want to make the lines semi-transparent, think about combining
    this function with the weighted_img() function below
    """

    # Initialize the Arrays to Store Left Line Coordinates
    x_left = []
    y_left = []

    # Initialize the Arrays to Store Right Line Coordinates
    x_right = []
    y_right = []

    # Array to Store Final Left Line Coordinates
    x_left_final = []
    y_left_final = []

    # Array to Store Final Right Line Coordinates
    x_right_final = []
    y_right_final = []

    # Middle of the image, till where we want our polygon lines
    x = img.shape[1]            # "X" dimension Value of Image
    mid = x/2

    # Take in the coordinates of lines generated by the Hough Transform one by one and analyze them.
    for line in lines:
        for x1,y1,x2,y2 in line:
            # Get the Slope from the Coordinates
            slope = (y2-y1)/(x2-x1)

            # Check that the line is either a left or a right line with the same slope, else move to next coordinates
            # If slope < 0: Left Lane
            # If slope > 0: Right Lane
            if slope < -0.5 or slope > 0.5:
                # If coordinates denote a Left Lane
                if slope < 0 and x1 < mid:
                    x_left.append(x1)
                    y_left.append(y1)
                    x_left.append(x2)
                    y_left.append(y2)
                # If the coordinates denote a Right Lane
                elif slope >= 0 and x1 > mid:
                    x_right.append(x1)
                    y_right.append(y1)
                    x_right.append(x2)
                    y_right.append(y2)

    # Now that we have the coordinates sorted for left and right lines, now we need to draw a line
    # For this, we use "Polynomial Interpolation", a technique under "Curve Fitting".
    # As the name suggests, the Aim of "Polynomial Interpolation" is to draw a line that passes through the coordinates that we have just separated.
    if x_left and y_left:
        # Draw a line that passes through points formed by "(x_left,y_left)".
        # Here, we need a straight line, so Order of Polynomial: "1"
        leftLine = np.poly1d(np.polyfit(x_left,y_left,1))

        # Now once we have the Line, we need to get the coordinates of the line lying only inside the ROI
        # We have defined the Arrays to store the final values of "x" and "y" coordinates within the ROI so that it does not see any other line
        # Use a for loop to get all the coordinates in the ROI into the final array
        for i in range(int(0.12*x),int(0.46*x)):
            if (leftLine(i) < x) and (leftLine(i) > 0):
                x_left_final.append(i)
                y_left_final.append(int(leftLine(i)))

    # Now that we have the coordinates sorted for left and right lines, now we need to draw a line
    # For this, we use "Polynomial Interpolation", a technique under "Curve Fitting".
    # As the name suggests, the Aim of "Polynomial Interpolation" is to draw a line that passes through the coordinates that we have just separated.
    if x_right and y_right:
        # Draw a line that passes through points formed by "(x_left,y_left)".
        # Here, we need a straight line, so Order of Polynomial: "1"
        rightLine = np.poly1d(np.polyfit(x_right, y_right, 1))

        # Now once we have the Line, we need to get the coordinates of the line lying only inside the ROI
        # We have defined the Arrays to store the final values of "x" and "y" coordinates within the ROI so that it does not see any other line
        # Use a for loop to get all the coordinates in the ROI into the final array
        for i in range(int(0.56 * x), int(0.95 * x)):
            if (rightLine(i) < x) and (rightLine(i) > 0):
                x_right_final.append(i)
                y_right_final.append(int(rightLine(i)))


    # Now that we have all the Final Lane Lines Coordinates, it's time to plot them
    # Plotting the Left Lane Lines
    for i in range(len(x_left_final) - 1):
        # Format: cv2.line(image, coordinates of point-1, coordinates of point-2, color, thickness)
        cv2.line(img, (x_left_final[i], y_left_final[i]),(x_left_final[i + 1], y_left_final[i + 1]), color, 5)

    # Plotting the Right Lane Lines
    for i in range(len(x_right_final) - 1):
        # Format: cv2.line(image, coordinates of point-1, coordinates of point-2, color, thickness)
        cv2.line(img, (x_right_final[i], y_right_final[i]), (x_right_final[i + 1], y_right_final[i + 1]), color, 5)


# Function to get the Filtered Hough Transform Lane Lines
def weighted_img(img, initial_img, α=0.8, β=1., λ=0.):
    """
    `img` is the output of the hough_lines(), An image with lines drawn on it.
    Should be a blank image (all black) with lines drawn on it.

    `initial_img` should be the image before any processing.

    The result image is computed as follows:

    initial_img * α + img * β + λ
    NOTE: initial_img and img must be the same shape!
    """
    return cv2.addWeighted(initial_img, α, img, β, λ)

# --------------------------------- EOC -----------------------------------